
# Contributing to LNN
Thank you for considering a contribution to Logical Neural Networks, with your assistance we can help grow LNNs as the industry's tool of choice for a true `Neuro = Symbolic` platform.

We commit to growing LNNs functionality, but we'd also love to see your name expanding into `x`, adding to growing our list of contributors:
```python
Contributions = Predicate("Contribution")
Growth = Propostion("LNNs Growth", world=World.TRUE)

Implies(Contributions(x), Growth)
```

## Software Setup

* Due to the complex inference pattern of LNNs upward and downward reasoning strategy, [Pycharm](https://www.jetbrains.com/pycharm/download/) is our recommended IDE of choice for development and debugging.
1. Make sure that the python version you are using corresponds with the [setup](https://github.com/IBM/LNN/blob/master/setup.py) file, using a fresh [conda]() environment is recommended:
    ```commandline
    conda create -n lnn-contrib python=3.9 -y
    conda activate lnn-contrib
    ```
3. Install the LNN module as editable
    ```commandline
    pip install -e git+https://github.com/IBM/LNN.git
    ```
* Install [Black](https://black.readthedocs.io/en/stable/integrations/editors.html) as an external tool/keyboard shortcut to keep to our code style - this automates our pep8 compliance so that you can code without the styling overhead
* Install and run pytest to ensure that the build is working correctly:
    ```commandline
    pip install pytest
    pytest
    ```

You are now ready to contribute changes to the codebase

##  Developing in LNN

### Propose a New Issue

1. You want to propose a new feature and implement it.
   1. Post about your intended feature in an [issue](https://github.com/IBM/LNN/issues/new), and we shall discuss the design and implementation.
   2. Once we agree that the plan looks good, go ahead and implement it.

* You may also want to implement a feature or bug-fix for an outstanding issue:
  * Pick an issue
  * Comment that you will be working on this issue.
  * Add yourself to the assignee list

  If you need more context on a particular issue, please ask for guidance.

### Branching

* LNN branches should follow [git flow][git flow] style branching

[<img src="https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=296" alt="git flow"/>][git flow]

To create a new feature branch:
   ```commandline
   git checkout -b feature/my_branch
   ```

Please be mindful of existing branches when creating a new branch.

### Pull Requests

1. Use `Black` formatting to ensure that code contributions abide by our code style
2. Commits should contain one of the following tags before the commit message: `ADD`, `FIX`, `MAINT`
3. **All commits require a [developer certificate of origin](https://github.com/apps/dco)**, please use the `git commit -s` flag appropriately.
4. Run `pytest` locally to ensure all changes pass

   NB: All code contributions corresponding to `enhancement` issues should have additional tests accompanying the code changes, located in the `tests/` folder.
4. Propose your code changes as a `Pull Request DRAFT`.
5. A passed draft can be changed to a formal `Pull Request`.
6. Add a reviewer to your code so that they can get notified of the proposal - the individual should correspond to the those charged with the yellow tag

### Documentation

LNN documentation can be generated by running `generate_docs.sh` in [docsrc][docsrc] folder.

[docsrc]: https://github.com/IBM/LNN/tree/develop/docsrc
[git flow]: https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

### Handling Circular Imports

A key component in the LNN code base is the `Formula` abstract class. `Formula` is a
class that refers to itself and the classes that inherit from it. As such, this can lead
to circular imports. To overcome circular imports we use dictionaries that are keyed
with the names of the subclasses and the values are the subclasses themselves. These
dictionaries are populated in the `__init__.py` of the logic module. Thus, when one
needs to work with a subclass, the subclass can be accessed by passing in the name of
that subclass to the dictionary. Note that not all classes that inherit from `Formula`
are added to these dictionaries. Please refer to `__init__.py` if you need to add an
existing class or new class to one of the dictionaries.
