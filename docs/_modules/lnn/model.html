<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <meta content="ie=edge" http-equiv="x-ua-compatible"/>
  <meta content="Copy to clipboard" name="lang:clipboard.copy"/>
  <meta content="Copied to clipboard" name="lang:clipboard.copied"/>
  <meta content="en" name="lang:search.language"/>
  <meta content="True" name="lang:search.pipeline.stopwords"/>
  <meta content="True" name="lang:search.pipeline.trimmer"/>
  <meta content="No matching documents" name="lang:search.result.none"/>
  <meta content="1 matching document" name="lang:search.result.one"/>
  <meta content="# matching documents" name="lang:search.result.other"/>
  <meta content="[\s\-]+" name="lang:search.tokenizer"/>
  <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&amp;display=fallback" rel="stylesheet"/>
  <style>
   body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
  </style>
  <link href="../../_static/stylesheets/application.css" rel="stylesheet"/>
  <link href="../../_static/stylesheets/application-palette.css" rel="stylesheet"/>
  <link href="../../_static/stylesheets/application-fixes.css" rel="stylesheet"/>
  <link href="../../_static/fonts/material-icons.css" rel="stylesheet"/>
  <meta content="#3f51b5" name="theme-color"/>
  <script src="../../_static/javascripts/modernizr.js">
  </script>
  <title>
   lnn.model — Logical Neural Networks Docs
  </title>
  <link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/material.css" rel="stylesheet" type="text/css"/>
  <link href="../../_static/copybutton.css" rel="stylesheet" type="text/css"/>
  <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js">
  </script>
  <script src="../../_static/jquery.js">
  </script>
  <script src="../../_static/underscore.js">
  </script>
  <script src="../../_static/_sphinx_javascript_frameworks_compat.js">
  </script>
  <script src="../../_static/doctools.js">
  </script>
  <script src="../../_static/sphinx_highlight.js">
  </script>
  <script src="../../_static/clipboard.min.js">
  </script>
  <script src="../../_static/copybutton.js">
  </script>
  <link href="../../genindex.html" rel="index" title="Index"/>
  <link href="../../search.html" rel="search" title="Search"/>
 </head>
 <body data-md-color-accent="cyan" data-md-color-primary="blue" dir="ltr">
  <svg class="md-svg">
   <defs data-children-count="0">
    <svg height="448" id="__github" viewbox="0 0 416 448" width="416" xmlns="http://www.w3.org/2000/svg">
     <path d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z" fill="currentColor">
     </path>
    </svg>
   </defs>
  </svg>
  <input class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
  <input class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
  <label class="md-overlay" data-md-component="overlay" for="__drawer">
  </label>
  <a class="md-skip" href="#_modules/lnn/model" tabindex="1">
   Skip to content
  </a>
  <header class="md-header" data-md-component="header">
   <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
     <div class="md-flex__cell md-flex__cell--shrink">
      <a class="md-header-nav__button md-logo" href="../../index.html" title="Logical Neural Networks Docs">
      </a>
     </div>
     <div class="md-flex__cell md-flex__cell--shrink">
      <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer">
      </label>
     </div>
     <div class="md-flex__cell md-flex__cell--stretch">
      <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
       <span class="md-header-nav__topic">
        Logical Neural Networks
       </span>
       <span class="md-header-nav__topic">
        lnn.model
       </span>
      </div>
     </div>
     <div class="md-flex__cell md-flex__cell--shrink">
      <label class="md-icon md-icon--search md-header-nav__button" for="__search">
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
       <label class="md-search__overlay" for="__search">
       </label>
       <div class="md-search__inner" role="search">
        <form action="../../search.html" class="md-search__form" method="get" name="search">
         <input autocapitalize="off" autocomplete="off" class="md-search__input" data-md-component="query" data-md-state="active" name="q" placeholder="Search" spellcheck="false" type="text"/>
         <label class="md-icon md-search__icon" for="__search">
         </label>
         <button class="md-icon md-search__icon" data-md-component="reset" tabindex="-1" type="reset">
          
         </button>
        </form>
        <div class="md-search__output">
         <div class="md-search__scrollwrap" data-md-scrollfix="">
          <div class="md-search-result" data-md-component="result">
           <div class="md-search-result__meta">
            Type to start searching
           </div>
           <ol class="md-search-result__list">
           </ol>
          </div>
         </div>
        </div>
       </div>
      </div>
     </div>
     <div class="md-flex__cell md-flex__cell--shrink">
      <div class="md-header-nav__source">
       <a class="md-source" data-md-source="github" href="https://github.com/IBM/LNN/" title="Go to repository">
        <div class="md-source__icon">
         <svg height="28" viewbox="0 0 24 24" width="28" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <use height="24" width="24" xlink:href="#__github">
          </use>
         </svg>
        </div>
        <div class="md-source__repository">
         LNN
        </div>
       </a>
      </div>
     </div>
     <script src="../../_static/javascripts/version_dropdown.js">
     </script>
     <script>
      var json_loc = "../../"versions.json"",
        target_loc = "../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
     </script>
    </div>
   </nav>
  </header>
  <div class="md-container">
   <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
     <ul class="md-tabs__list">
      <li class="md-tabs__item">
       <a class="md-tabs__link" href="../../index.html">
        Logical Neural Networks Docs
       </a>
      </li>
      <li class="md-tabs__item">
       <a class="md-tabs__link" href="../index.html">
        Module code
       </a>
      </li>
     </ul>
    </div>
   </nav>
   <main class="md-main">
    <div class="md-main__inner md-grid" data-md-component="container">
     <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
      <div class="md-sidebar__scrollwrap">
       <div class="md-sidebar__inner">
        <nav class="md-nav md-nav--primary" data-md-level="0">
         <label class="md-nav__title md-nav__title--site" for="__drawer">
          <a class="md-nav__button md-logo" href="../../index.html" title="Logical Neural Networks Docs">
           <img alt=" logo" height="48" src="../../_static/" width="48"/>
          </a>
          <a href="../../index.html" title="Logical Neural Networks Docs">
           Logical Neural Networks
          </a>
         </label>
         <div class="md-nav__source">
          <a class="md-source" data-md-source="github" href="https://github.com/IBM/LNN/" title="Go to repository">
           <div class="md-source__icon">
            <svg height="28" viewbox="0 0 24 24" width="28" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
             <use height="24" width="24" xlink:href="#__github">
             </use>
            </svg>
           </div>
           <div class="md-source__repository">
            LNN
           </div>
          </a>
         </div>
         <ul class="md-nav__list">
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../introduction.html">
            Logical Neural Networks
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../usage.html">
            Python API
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../papers.html">
            Papers
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../education/education.html">
            Education
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../lnn/LNN.html">
            LNN Module
           </a>
          </li>
         </ul>
        </nav>
       </div>
      </div>
     </div>
     <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
      <div class="md-sidebar__scrollwrap">
       <div class="md-sidebar__inner">
        <nav class="md-nav md-nav--secondary">
         <ul class="md-nav__list" data-md-scrollfix="">
          <li class="md-nav__item" id="searchbox">
          </li>
         </ul>
        </nav>
       </div>
      </div>
     </div>
     <div class="md-content">
      <article class="md-content__inner md-typeset" role="main">
       <h1 id="modules-lnn-model--page-root">
        Source code for lnn.model
       </h1>
       <div class="highlight">
        <pre>
<span></span><span class="c1">##</span>
<span class="c1"># Copyright 2023 IBM Corp. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>
<span class="c1">##</span>

<span class="c1"># flake8: noqa: E501</span>

<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">itls</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">viz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_exceptions</span><span class="p">,</span> <span class="n">_utils</span>
<span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="n">Fact</span><span class="p">,</span> <span class="n">World</span><span class="p">,</span> <span class="n">Direction</span><span class="p">,</span> <span class="n">Loss</span>
<span class="kn">from</span> <span class="nn">.symbolic.logic</span> <span class="kn">import</span> <span class="n">Proposition</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">,</span> <span class="n">Formula</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">_utils</span><span class="o">.</span><span class="n">logger_setup</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="Model"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model">[docs]</a><span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Creates a container for logical reasoning and neural learning.</span>

<span class="sd">    Models define a theory or a collection of formulae, with additional reasoning and</span>
<span class="sd">        learning functionality that can be applied to each formula in the model.</span>
<span class="sd">        In contrast to standard FOL where the existence of a formula symbol assumes a</span>
<span class="sd">        `True` truth value, the data associated with LNN formulae can take on any</span>
<span class="sd">        classical truth (Fact) or belief bounds (a range real-values).</span>

<span class="sd">    Models are also dynamic, instantiated as empty containers which are later populated</span>
<span class="sd">        with knowledge rules and data. This additionally allows LNNs to operate in</span>
<span class="sd">        dynamic environments whereby the knowledge acquired may grow as new</span>
<span class="sd">        information becomes available.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name of contextual model, defaults to "Model"</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : nx.DiGraph</span>
<span class="sd">        Directed graph that connects nodes, pointing from operator to operand nodes.</span>
<span class="sd">    nodes : dict</span>
<span class="sd">        Each formula is keyed by a formula_number, with the value as the formula object.</span>
<span class="sd">    query : Formula</span>
<span class="sd">        A formula node that is set as the current query - allows the model to be used in QA/theorem proving whereby inference is governed towards solving the query.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    # define the predicates</span>
<span class="sd">    x, y = Variables("x", "y")</span>
<span class="sd">    Smokes, Asthma, Cough = Predicates("Smokes", "Asthma", "Cough")</span>
<span class="sd">    Friends = Predicate("Friends", arity=2)</span>

<span class="sd">    # define the connectives/quantifiers</span>
<span class="sd">    Smokers_have_friends = And(Smokes(x), Friends(x, y))</span>
<span class="sd">    Asthmatic_smokers_cough = (</span>
<span class="sd">        Exists(x, Implies(And(Smokes(x), Asthma(x)), Cough(x))))</span>
<span class="sd">    Smokers_befriend_smokers = (</span>
<span class="sd">        Forall(x, y, Implies(Smokers_have_friends(x, y), Smokes(y))))</span>

<span class="sd">    # add root formulae to model</span>
<span class="sd">    model = Model()</span>
<span class="sd">    model.add_knowledge(</span>
<span class="sd">        Asthmatic_smokers_cough,</span>
<span class="sd">        Smokers_befriend_smokers)</span>

<span class="sd">    # add data to the model</span>
<span class="sd">    model.add_data({</span>
<span class="sd">        Smokes: {</span>
<span class="sd">            "Person_1": Fact.TRUE,</span>
<span class="sd">            "Person_2": Fact.UNKNOWN,</span>
<span class="sd">            "Person_3": Fact.UNKNOWN},</span>
<span class="sd">        Friends: {</span>
<span class="sd">            ("Person_1", "Person_2"): Fact.TRUE,</span>
<span class="sd">            ("Person_2", "Person_3"): Fact.UNKNOWN}})</span>

<span class="sd">    # reason over the model</span>
<span class="sd">    model.infer()</span>

<span class="sd">    # verify the model outputs</span>
<span class="sd">    model.print()</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">knowledge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Formula</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"Model"</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_formulae</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_converge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">knowledge</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">knowledge</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_knowledge</span><span class="p">(</span><span class="o">*</span><span class="n">knowledge</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_knowledge</span><span class="p">(</span><span class="n">knowledge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="s2"> "</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">"*"</span> <span class="o">*</span> <span class="mi">22</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Formula</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Formula</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Returns a formula object from the model.</span>

<span class="sd">        If the formula is in the model, return the formula</span>
<span class="sd">            - for backward compatibility</span>
<span class="sd">        if multiple formula exists in the model with the same structure,</span>
<span class="sd">            return a list of all the relevant nodes</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">formula</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">formula_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">formula</span><span class="o">.</span><span class="n">formula_number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">formula</span><span class="o">.</span><span class="n">formula_number</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="p">[</span><span class="n">formula</span><span class="o">.</span><span class="n">structure</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">result</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="p">[</span><span class="n">formula</span><span class="o">.</span><span class="n">structure</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">formula_number</span> <span class="ow">and</span> <span class="n">formula</span><span class="o">.</span><span class="n">formula_number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">formula</span><span class="o">.</span><span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span>

<div class="viewcode-block" id="Model.set_query"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.set_query">[docs]</a>    <span class="k">def</span> <span class="nf">set_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="n">world</span><span class="o">=</span><span class="n">World</span><span class="o">.</span><span class="n">OPEN</span><span class="p">,</span> <span class="n">converge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Inserts a query node into the model and maintains a handle on the node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formula : Formula</span>
<span class="sd">            Name of contextual model</span>
<span class="sd">        world : World</span>
<span class="sd">            Default behavior of the formula. If unspecified, assumes open world assumption.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The query formula will be added to the model and will not be removed, even if a new query is defined using this function.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_knowledge</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">world</span><span class="o">=</span><span class="n">world</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">formula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_converge</span> <span class="o">=</span> <span class="n">converge</span></div>

<div class="viewcode-block" id="Model.infer_query"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.infer_query">[docs]</a>    <span class="k">def</span> <span class="nf">infer_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Reasons only over the stored query.</span>

<span class="sd">        Is the same as calling [model.infer](#lnn.Model.infer) but setting the source</span>
<span class="sd">        node as [model.query](#lnn.Model.set_query)."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">add_formulae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"`add_formulae` is deprecated, use `add_knowledge` instead"</span><span class="p">)</span>

<div class="viewcode-block" id="Model.add_knowledge"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.add_knowledge">[docs]</a>    <span class="k">def</span> <span class="nf">add_knowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="n">world</span><span class="p">:</span> <span class="n">World</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Extend the model to include additional formulae.</span>

<span class="sd">        Only root level formulae explicitly need to be added to the model.</span>
<span class="sd">        Unless otherwise specified, each root formula follows the open world</span>
<span class="sd">        assumption.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        P, Q = Predicates("P1", "Q")</span>
<span class="sd">        model.add_knowledge(P, Q)</span>

<span class="sd">        ```</span>
<span class="sd">        creates the predicate and inserts into the model</span>

<span class="sd">        or</span>

<span class="sd">        ```python</span>
<span class="sd">        model = Model()</span>
<span class="sd">        P1 = Predicate("P1")</span>
<span class="sd">        P2 = Predicate("P2", 2)</span>
<span class="sd">        P3 = Predicate("P3", 3)</span>
<span class="sd">        model.add_knowledge(</span>
<span class="sd">            And(P1(x), P2(x, y)),</span>
<span class="sd">            Implies(P2(x, y), P3(x, y, z))</span>
<span class="sd">        )</span>

<span class="sd">        ```</span>

<span class="sd">        inserts the formulae roots into the model and appropriately includes</span>
<span class="sd">        all subformulae also into the scope of the model.</span>

<span class="sd">        Any formulae that directly require inquiry should first be created in</span>
<span class="sd">        the user scope and thereafter inserted into the model for reference</span>
<span class="sd">        after reasoning/learning</span>

<span class="sd">        e.g.</span>

<span class="sd">        ```python</span>
<span class="sd">        model = Model()</span>
<span class="sd">        P1 = Predicate("P1")</span>
<span class="sd">        P2 = Predicate("P2", 2)</span>
<span class="sd">        P3 = Predicate("P3", 3)</span>
<span class="sd">        my_and = And(P1(x), P2(x, y))</span>
<span class="sd">        model.add_knowledge(</span>
<span class="sd">            my_and,</span>
<span class="sd">            Implies(P2(x, y), P3(x, y, z))</span>
<span class="sd">        )</span>

<span class="sd">        ...</span>
<span class="sd">        model.infer()</span>
<span class="sd">        ...</span>

<span class="sd">        my_and.state()</span>

<span class="sd">        ```</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_knowledge</span><span class="p">(</span><span class="o">*</span><span class="n">formulae</span><span class="p">,</span> <span class="n">world</span><span class="o">=</span><span class="n">world</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">add_propositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">Proposition</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_knowledge</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">add_predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">Predicate</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="n">arity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_knowledge</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">replace_graph_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">old_edge</span><span class="p">:</span> <span class="p">(</span><span class="n">Formula</span><span class="p">,</span> <span class="n">Formula</span><span class="p">),</span> <span class="n">new_edge</span><span class="p">:</span> <span class="p">(</span><span class="n">Formula</span><span class="p">,</span> <span class="n">Formula</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">old_edge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_knowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="n">world</span><span class="p">:</span> <span class="n">World</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">formulae</span><span class="p">):</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertFormula</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">edge_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_formulae</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">set_formula_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_formulae</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">structure</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">structure</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_structures</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">node</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span> <span class="p">[</span><span class="n">node</span><span class="p">]})</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">node</span><span class="p">]})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">formula_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">if</span> <span class="n">world</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">formulae</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">reset_world</span><span class="p">(</span><span class="n">world</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_facts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"`add_facts` is deprecated, use `add_data` instead"</span><span class="p">)</span>

<div class="viewcode-block" id="Model.add_data"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.add_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="n">Formula</span><span class="p">,</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Fact</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                <span class="n">Dict</span><span class="p">[</span>
                    <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
                    <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Fact</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                <span class="p">],</span>
            <span class="p">],</span>
        <span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Add data to select formulae in the model, in the form of classical facts or belief bounds.</span>

<span class="sd">        Data given is a Fact or belief bounds assumes a propositional formula.</span>
<span class="sd">        Data given in a dict assumes a first-order logic formula,</span>
<span class="sd">            keyed by the grounding and a value given as a Fact or belief bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : a dict of Fact, belief bounds or dict</span>
<span class="sd">            The dict is keyed by the formula for which data is to be added, with the truths as the value. For propositional formulae, truths are given as either Facts or belief bounds. These beliefs can be given as a bool, float or a float-range, i.e. a tuple of 2 floats. For first-order logic formula, inputs truths are given as a dict. This is further keyed by the grounding (a str for unary formlae or tuple of strings of larger arities), with values also as Facts or bounds on beliefs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # propositional</span>
<span class="sd">        P = Proposition("Person")</span>
<span class="sd">        model.add_data({</span>
<span class="sd">            P: Fact.TRUE</span>
<span class="sd">        })</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        # first-order logic</span>
<span class="sd">        Person = Predicate("Person")</span>
<span class="sd">        BD = Predicate("Birthdate", 2)</span>
<span class="sd">        model.add_data({</span>
<span class="sd">            Person: {</span>
<span class="sd">                "Barack Obama": Fact.TRUE,</span>
<span class="sd">                "Bo": (.1, .4)</span>
<span class="sd">            },</span>
<span class="sd">            BD: {</span>
<span class="sd">                ("Barack Obama", "04 August 1961"): Fact.TRUE,</span>
<span class="sd">                ("Bo", "09 October 2008"): (.6, .75)</span>
<span class="sd">            }</span>
<span class="sd">        })</span>
<span class="sd">        ```</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Assumes that the formulae have already been inserted into the model, see [add_knowledge](https://ibm.github.io/LNN/lnn/LNN.html#lnn.Model.add_knowledge) for more details.</span>

<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">formula</span><span class="p">,</span> <span class="n">fact</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">Formula</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">"formula expected of type Formula, received "</span>
                    <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">formula</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">"</span>
                <span class="p">)</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertFormulaInModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertBounds</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertFOLFacts</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>
            <span class="n">formula</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.add_labels"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.add_labels">[docs]</a>    <span class="k">def</span> <span class="nf">add_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
            <span class="n">Formula</span><span class="p">,</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span>
            <span class="p">],</span>
        <span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Add labels to select formulae in the model, in the form of classical facts or belief bounds.</span>

<span class="sd">        Labels given is a Fact or belief bounds assumes a propositional formula.</span>
<span class="sd">        Labels given in a dict assumes a first-order logic formula,</span>
<span class="sd">            keyed by the grounding and a value given as a Fact or belief bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : a dict of Fact, belief bounds or dict</span>
<span class="sd">            The dict is keyed by the formula for which data is to be added, with the truths as the value. For propositional formulae, truths are given as either Facts or belief bounds (a tuple of 2 floats). For first-order logic formula, inputs truths are given as a dict. This is further keyed by the grounding (a str for unary formlae or tuple of strings of larger arities), with values also as Facts or bounds on beliefs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # propositional</span>
<span class="sd">        P = Proposition("Person")</span>
<span class="sd">        model.add_labels({</span>
<span class="sd">            P: Fact.TRUE</span>
<span class="sd">        })</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        # first-order logic</span>
<span class="sd">        Person = Predicate("Person")</span>
<span class="sd">        BD = Predicate("Birthdate", 2)</span>
<span class="sd">        model.add_labels({</span>
<span class="sd">            Person: {</span>
<span class="sd">                "Barack Obama": Fact.TRUE,</span>
<span class="sd">                "Bo": (.1, .4)</span>
<span class="sd">            },</span>
<span class="sd">            BD: {</span>
<span class="sd">                ("Barack Obama", "04 August 1961"): Fact.TRUE,</span>
<span class="sd">                ("Bo", "09 October 2008"): (.6, .75)</span>
<span class="sd">            }</span>
<span class="sd">        })</span>
<span class="sd">        ```</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Assumes that the formulae have already been inserted into the model, see [add_knowledge](https://ibm.github.io/LNN/lnn/LNN.html#lnn.Model.add_knowledge) for more details.</span>

<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">formula</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertFormulaInModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertBounds</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertFOLFacts</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">formula</span><span class="o">.</span><span class="n">add_labels</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_traverse_execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span> <span class="o">=</span> <span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Traverse over the subgraph and execute an operation per node starting from</span>
<span class="sd">        source.</span>

<span class="sd">        Traverses through graph from `source` in the given `direction`</span>
<span class="sd">            and execute `func` at each node</span>

<span class="sd">        """</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertValidDirection</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_postorder_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_postorder_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">))))</span>

        <span class="n">coalesce</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">func</span><span class="p">)(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">coalesce</span> <span class="o">=</span> <span class="n">coalesce</span> <span class="o">+</span> <span class="n">val</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coalesce</span>
        <span class="k">if</span> <span class="n">coalesce</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">Direction</span><span class="p">]:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">direction</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> INFERENCE RESULT:</span><span class="si">{</span><span class="n">coalesce</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coalesce</span>

<div class="viewcode-block" id="Model.infer"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.infer">[docs]</a>    <span class="k">def</span> <span class="nf">infer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Reasons over all possible inferences until convergence</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        direction : {Direction.UPWARD, Direction.DOWNWARD}, optional</span>
<span class="sd">            Can be specified as either UPWARD or DOWNWARD inference, a single pass of that direction will be applied. If unspecified, defaults to the LNN naive inference strategy of doing inference until convergence.</span>
<span class="sd">        source : node, optional</span>
<span class="sd">            Specifies starting node for [depth-first search traversal](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.traversal.depth_first_search.dfs_postorder_nodes.html#networkx.algorithms.traversal.depth_first_search.dfs_postorder_nodes). Specifying a node here will compute reasoning (until convergence) on the subgraph, with the specified source is the root of the subgraph.</span>
<span class="sd">        max_steps: int, optional</span>
<span class="sd">            Limits the inference to a specified number of passes of the naive traversal strategy. If unspecified, the steps will not be limited, i.e. inference will take place until convergence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (steps, facts_inferred) : Tuple[tuple of 2 ints, torch.Tensor]</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer</span><span class="p">(</span>
            <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
            <span class="n">max_steps</span><span class="o">=</span><span class="n">max_steps</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_infer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Implementation of model inference."""</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">direction</span> <span class="k">else</span> <span class="p">[</span><span class="n">direction</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">additional_axioms</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">facts_inferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">converged</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">is_classically_resolved</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_converge</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"="</span> <span class="o">*</span> <span class="mi">22</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"QUERY PROVED AS </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">world_state</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s2"> for "</span>
                    <span class="sa">f</span><span class="s2">"'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">'"</span>
                <span class="p">)</span>
                <span class="k">break</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"-"</span> <span class="o">*</span> <span class="mi">22</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">"REASONING STEP:</span><span class="si">{</span><span class="n">steps</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="n">bounds_diff</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
                <span class="n">bounds_diff</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
                <span class="p">)</span>
            <span class="n">converged_bounds</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">True</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">([[</span><span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">],</span> <span class="p">[</span><span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span><span class="p">]])</span>
                <span class="k">else</span> <span class="n">bounds_diff</span> <span class="o">&lt;=</span> <span class="mf">1e-7</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">converged_bounds</span><span class="p">:</span>
                <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"NO UPDATES AVAILABLE, TRYING A NEW AXIOM"</span><span class="p">)</span>
            <span class="n">facts_inferred</span> <span class="o">+=</span> <span class="n">bounds_diff</span>
            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">max_steps</span> <span class="ow">and</span> <span class="n">steps</span> <span class="o">&gt;=</span> <span class="n">max_steps</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"="</span> <span class="o">*</span> <span class="mi">22</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">"INFERENCE CONVERGED WITH </span><span class="si">{</span><span class="n">facts_inferred</span><span class="si">}</span><span class="s2"> BOUNDS "</span>
            <span class="sa">f</span><span class="s2">"UPDATES IN </span><span class="si">{</span><span class="n">steps</span><span class="si">}</span><span class="s2"> REASONING STEPS "</span>
        <span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"*"</span> <span class="o">*</span> <span class="mi">78</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">steps</span><span class="p">,</span> <span class="n">facts_inferred</span>

<div class="viewcode-block" id="Model.upward"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.upward">[docs]</a>    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Performs upward inference for each node in the model from leaf to root."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.downward"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.downward">[docs]</a>    <span class="k">def</span> <span class="nf">downward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Performs downward inference for each node in the model from root to leaf."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Model.train"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">losses</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Loss</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Loss</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Loss</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">"""Train the model.</span>

<span class="sd">        Reasons across the model until convergence using the standard inference</span>
<span class="sd">        strategy - equivalent to running a NN in the forward direction.</span>
<span class="sd">        At the end of each reasoning pass losses are calculated according to a</span>
<span class="sd">        predefined or custom loss and model parameters are updated.</span>
<span class="sd">        An epoch constitutes all computation until parameters take a step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        losses: Loss, list or dict of losses</span>
<span class="sd">            Predefined losses expected from the fixed Loss constants. If given in dict form, coefficients of each loss can be specified as a float value. The value can alternatively specify additional parameters for each loss calculation using a dict.</span>
<span class="sd">        optimizer : pytorch optimizer, optional</span>
<span class="sd">            Custom optimizers should be instantiated with the model parameters using `model.parameters()`. If unspecified, defaults to [Adam](https://pytorch.org/docs/stable/generated/torch.optim.Adam.html#torch.optim.Adam).</span>
<span class="sd">        learning_rate : float, optional</span>
<span class="sd">            If unspecified, defaults to 5e-2.</span>
<span class="sd">        epochs : float, optional</span>
<span class="sd">            Number of training epochs. If unspecified, trains for 3e2 epochs.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Prints out a tqdm training progress bar. If unspecified, does not print out.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (epochs, total_loss) : Tuple[int, Tuple[List, Tensor]]</span>
<span class="sd">            A tuple of variables are returned. The `epochs` is number of epochs trained before stopped/converged + 1. The `total_loss` returns a tuple of 2 values: first is the `running_loss` as a list for the sum of loss at the end of each epoch; then the `loss_history`, which is a Tensor of individual loss components as specified by the `losses` argument.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # construct the model from formulae</span>
<span class="sd">        model = Model()</span>
<span class="sd">        p1, p2 = Predicates("P1", "P2")</span>
<span class="sd">        x = Variable("x")</span>
<span class="sd">        AB = And(p1(x), p2(x))</span>
<span class="sd">        model.add_knowledge(AB)</span>

<span class="sd">        # add data to the model</span>
<span class="sd">        model.add_data({</span>
<span class="sd">            p1: {</span>
<span class="sd">                "0": Fact.TRUE,</span>
<span class="sd">                "1": Fact.TRUE,</span>
<span class="sd">                '2': Fact.FALSE,</span>
<span class="sd">                '3': Fact.FALSE</span>
<span class="sd">            },</span>
<span class="sd">            p2: {</span>
<span class="sd">                '0': Fact.TRUE,</span>
<span class="sd">                '1': Fact.FALSE,</span>
<span class="sd">                '2': Fact.TRUE,</span>
<span class="sd">                '3': Fact.FALSE,</span>
<span class="sd">            }</span>
<span class="sd">        })</span>

<span class="sd">        # add supervisory targets</span>
<span class="sd">        model.add_labels({</span>
<span class="sd">            AB: {</span>
<span class="sd">                '0': Fact.TRUE,</span>
<span class="sd">                '1': Fact.FALSE,</span>
<span class="sd">                '2': Fact.TRUE,</span>
<span class="sd">                '3': Fact.FALSE,</span>
<span class="sd">            }</span>
<span class="sd">        })</span>

<span class="sd">        # train the model and output results</span>
<span class="sd">        model.train(losses=Loss.SUPERVISED)</span>
<span class="sd">        model.print(params=True)</span>
<span class="sd">        ```</span>

<span class="sd">        """</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">"optimizer"</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span>
                <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"parameters"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">()),</span>
                <span class="n">lr</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"learning_rate"</span><span class="p">,</span> <span class="mf">5e-2</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">running_loss</span><span class="p">,</span> <span class="n">loss_history</span><span class="p">,</span> <span class="n">inference_history</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"epochs"</span><span class="p">,</span> <span class="mf">3e2</span><span class="p">))),</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">"training epoch"</span><span class="p">,</span>
            <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pbar"</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">" PARAMETER STEP "</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">"#"</span> <span class="o">*</span> <span class="mi">31</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reset_bounds</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">increment_param_history</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"parameter_history"</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">facts_inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="n">loss_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_fn</span><span class="p">(</span><span class="n">losses</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">loss_fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">loss</span><span class="o">.</span><span class="n">grad_fn</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">loss</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">loss_fn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">"TOTAL LOSS: </span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_project_params</span><span class="p">()</span>
            <span class="n">running_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="n">loss_history</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">L</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">loss_fn</span><span class="p">])</span>
            <span class="n">inference_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">facts_inferred</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">loss</span> <span class="o">&lt;=</span> <span class="mf">1e-7</span> <span class="ow">and</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"stop_at_convergence"</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_bounds</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increment_param_history</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"parameter_history"</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">running_loss</span><span class="p">,</span> <span class="n">loss_history</span><span class="p">),</span> <span class="n">inference_history</span></div>

<div class="viewcode-block" id="Model.parameters"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.parameters">[docs]</a>    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itls</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">parameters_grouped_by_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">param_group</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">param_group</span><span class="p">[</span><span class="s2">"params"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">param_group</span><span class="p">[</span><span class="s2">"param_names"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
                <span class="n">param_group</span><span class="p">[</span><span class="s2">"params"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                <span class="n">param_group</span><span class="p">[</span><span class="s2">"param_names"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">param_group</span><span class="p">[</span><span class="s2">"neuron_type"</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_group</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Model.named_parameters"><a class="viewcode-back" href="../../lnn/LNN.html#lnn.Model.named_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">named_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">:</span> <span class="n">param</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()}</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">loss_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">losses</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">losses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">"no loss function given, "</span>
                <span class="sa">f</span><span class="s2">"expected losses from the following </span><span class="si">{</span><span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">Loss</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="n">Loss</span><span class="p">):</span>
            <span class="n">losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">losses</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">losses</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">losses</span><span class="p">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">losses</span><span class="p">:</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertLossType</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="n">Loss</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">loss</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">"custom losses expected as a dict with keys as "</span>
                        <span class="s2">"name of the loss and values as function "</span>
                        <span class="s2">"definitions"</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">loss_fn</span> <span class="ow">in</span> <span class="n">losses</span><span class="p">[</span><span class="n">loss</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">coalesce</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_postorder_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)):</span>
                        <span class="n">coalesce</span> <span class="o">=</span> <span class="n">coalesce</span> <span class="o">+</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coalesce</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwds</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">losses</span><span class="p">[</span><span class="n">loss</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">loss</span><span class="p">],</span> <span class="nb">dict</span><span class="p">))</span>
                    <span class="k">else</span> <span class="p">({</span><span class="s2">"coeff"</span><span class="p">:</span> <span class="n">losses</span><span class="p">[</span><span class="n">loss</span><span class="p">]})</span>
                <span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">"_</span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">_loss"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> LOSS </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Formula</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">roundoff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">grads</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">numbering</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">header_len</span> <span class="o">+</span> <span class="mi">25</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> <span class="s2">"*"</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">'</span><span class="se">\n</span><span class="si">{</span><span class="s2">""</span><span class="si">:</span><span class="s1">&lt;</span><span class="si">{</span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="si">}}</span><span class="s1">LNN </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span>
            <span class="s2">"print"</span><span class="p">,</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
            <span class="n">header_len</span><span class="o">=</span><span class="n">header_len</span><span class="p">,</span>
            <span class="n">roundoff</span><span class="o">=</span><span class="n">roundoff</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">grads</span><span class="o">=</span><span class="n">grads</span><span class="p">,</span>
            <span class="n">numbering</span><span class="o">=</span><span class="n">numbering</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"*"</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">formula_number</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">edge_variables</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">):</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"with_labels"</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">"arrows"</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">"edge_color"</span><span class="p">:</span> <span class="s2">"#d0e2ff"</span><span class="p">,</span>
            <span class="s2">"node_color"</span><span class="p">:</span> <span class="s2">"#ffffff"</span><span class="p">,</span>
            <span class="s2">"node_size"</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
            <span class="s2">"font_size"</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">pos</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">formula_number</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">formula_number</span>
                    <span class="k">else</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">connective_str</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">"connective_str"</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
                <span class="p">]</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_variables</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">edge</span><span class="p">:</span> <span class="n">_utils</span><span class="o">.</span><span class="n">list_to_str</span><span class="p">(</span>
                    <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operand_map</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Predicate</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">pos</span><span class="p">,</span>
                <span class="n">labels</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span><span class="s2">"flush"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span><span class="s2">"reset_bounds"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_project_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span><span class="s2">"project_params"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">increment_param_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_history</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parameter_history</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_execute</span><span class="p">(</span>
                <span class="s2">"increment_param_history"</span><span class="p">,</span> <span class="n">parameter_history</span><span class="o">=</span><span class="n">parameter_history</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_contradiction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="k">else</span> <span class="kc">False</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">groundings</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="mi">1</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">propositional</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">groundings</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">groundings</span><span class="p">]</span></div>
</pre>
       </div>
      </article>
     </div>
    </div>
   </main>
  </div>
  <footer class="md-footer">
   <div class="md-footer-nav">
    <nav class="md-footer-nav__inner md-grid">
    </nav>
   </div>
   <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
     <div class="md-footer-copyright">
      <div class="md-footer-copyright__highlight">
       © Copyright 2020, IBM Research.
      </div>
      Created using
      <a href="http://www.sphinx-doc.org/">
       Sphinx
      </a>
      5.3.0.
             and
      <a href="https://github.com/bashtage/sphinx-material/">
       Material for
              Sphinx
      </a>
     </div>
    </div>
   </div>
  </footer>
  <script src="../../_static/javascripts/application.js">
  </script>
  <script>
   app.initialize({version: "1.0.4", url: {base: ".."}})
  </script>
 </body>
</html>